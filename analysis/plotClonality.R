#' @title plotClonality()
#' @description Plot stacked barplot of total, shared and non-shared breakpoints and breakclone score per sample for copy number data.
#' @param x A data frame with the following columns for the samples to plot: pat_id (patients IDs), sample1 (sample 1 IDs), sample2 (sample 2 IDs), relatedness (one of Related, Unrelated or Ambiguous), pair score (breakclone clonality score)
#' @param segmentTable A segment table generated by the breakclone::readAlleleSpecific or breakclone::readVCFCn functions. Also a list with a segment table of each type to plot both kind of data together.
#' @param breakdir A character vector with the directory to the shared breakpoints exported with exportSharedBreaks() function.
#' @param bSize A numeric character vector with the bin size.
#' @param cnType The type of copy number data provided. Currently supported options are a custom allele specific data format, and standard copy number VCF files.
#' @details 
#' @examples 
#' x <- data.frame(pat_id = master$newID, sample1 = master$sample1, sample2 = master$sample2, relatedness = master$relatedness, pair_scores = master$pair_scores)
#' plotClonality(x, segmentTable, breakdir = breakdir)
#' @export
plotClonality <- function(x, segmentTable, breakdir = ".", bSize = 100){
    #read the breakpoints
    breaks <- dir(breakdir, "*.tsv", full.names = TRUE)
    pairs <- gsub(".tsv", "", dir(breakdir, "*.tsv", full.names = FALSE))
    
    breaks <- lapply(breaks, data.table::fread)
    names(breaks) <- pairs
    
    #load the bins positions
    bins <- rownames(Biobase::pData(QDNAseq::getBinAnnotations(binSize = bSize)))
    chr <- paste0("chr", gsub("\\:.*", "", bins))
    start <- as.numeric(gsub('.*\\:', "", gsub("\\-.*", "", bins)))
    end <- as.numeric(gsub('.*\\-', "", bins))
    
    #calls for alleleSpecific type
    if (cnType == "alleleSpecific"){
        #function from breakclone package
        handlePloidy <- function(sample){
            sample$segLen <- sample$End - sample$Start
            sample_states <- aggregate(segLen ~ nTotal, sample, sum)
            sample_states$adjLen <- as.numeric(sample_states$nTotal) * sample_states$segLen
            sample_ploidy <- sum(sample_states$adjLen) / sum(sample$segLen)
            
            if(sample_ploidy >= 3.5){
                warning("Sample ", sample$SampleID[1], " looks WGD, inferring ancestral Cn state")
                sample$nTotal <- ifelse(sample$nMinor == (sample$nTotal / 2), 2, sample$nTotal)
                sample$nTotal <- ifelse(sample$nMinor == 0, 1, sample$nTotal)
                sample$nTotal <- ifelse(sample$nTotal >= 3 & sample$nTotal <= 4 & sample$nMinor == 1, 2, sample$nTotal)
                sample$nTotal <- ifelse(sample$nTotal >= 5 & sample$nTotal <= 10, 3, sample$nTotal)
            }
            return(sample)
        }
        
        segmentTable$nTotal <- segmentTable$nMajor + segmentTable$nMinor
        segmentTable <- handlePloidy(segmentTable)
        segmentTable$status <- ifelse(segmentTable$nTotal < 2, "loss", ifelse(segmentTable$nTotal == 2 & segmentTable$nMinor == 1, "norm", ifelse(segmentTable$nTotal == 2 & segmentTable$nMinor == 0, "cnloh", ifelse(segmentTable$nTotal > 4, "amp", "gain"))))
        segmentTable <- segmentTable[!"norm", on = "status"]
    }
    
    #classify breakpoints
    x$shared_bp <- NA
    x$non_shared_bp_sample1 <- NA
    x$non_shared_bp_sample2 <- NA
    x$total_bp <- NA
    x$sample1_bp <- NA
    x$sample2_bp <- NA
    for (j in 1:nrow(x)){
        message("Sample ", j, " out of ", nrow(x))
        s1 <- x[j,"sample1"]  
        s2 <- x[j,"sample2"]
        
        #find shared breakpoints
        shared <- breaks[names(breaks) == paste0(s1, "_", s2)][[1]]
        
        start.tab <- na.omit(shared[1:which(shared[,1] == "seqnames")-1,])
        start.tab.new <- start.tab
        if ( nrow(start.tab) != 0 ){
            for (i in 1:nrow(start.tab)){
                if ( start.tab$start[i] == 1 ){
                    start.tab.new <- start.tab.new[-i,]
                }
            }
        }
        start.tab <- start.tab.new
        
        end.tab <- na.omit(shared[which(shared[,1] == "seqnames")+1:nrow(shared),])
        end.tab.new <- end.tab
        if ( nrow(end.tab) != 0 ){
            for (i in 1:nrow(end.tab)){
                mx <- max(end[chr == end.tab$seqnames[i]]) 
                if ( end.tab$end[i] == mx ){
                    end.tab.new <- end.tab.new[-i,]
                }
            }
        }
        end.tab <- end.tab.new

        x$shared_bp[j] <- nrow(rbind(start.tab, end.tab))*2
        
        #find non-shared breakpoints
        segs1 <- segmentTable[segmentTable$SampleID == s1,]
        segs2 <- segmentTable[segmentTable$SampleID == s2,]
        
        n1 <- nrow(segs1)
        n2 <- nrow(segs2)
        
        x$non_shared_bp_sample1[j] <- n1*2 - x$shared_bp[j]
        x$non_shared_bp_sample2[j] <- n2*2 - x$shared_bp[j]
        
        # remove aberrations in the edges of chromosomes
        start.tab <- segs1
        colnames(start.tab)[1:4] <- c("SampleID", "seqnames", "start", "end")
        start.tab.new <- start.tab
        if ( nrow(start.tab) != 0 ){
            for (i in 1:nrow(start.tab)){
                if ( start.tab$start[i] == 1 ){
                    start.tab.new <- start.tab.new[-i,]
                }
            }
        }
        s1.start <- start.tab.new
        
        end.tab <- segs1
        colnames(end.tab)[1:4] <- c("SampleID", "seqnames", "start", "end")
        end.tab.new <- end.tab
        if ( nrow(end.tab) != 0 ){
            for (i in 1:nrow(end.tab)){
                mx <- max(m.end[which(m.chr == end.tab$seqnames[i])]) 
                if ( end.tab$end[i] == mx ){
                    end.tab.new <- end.tab.new[-i,]
                }
            }
        }
        s1.end <- end.tab.new
        
        start.tab <- segs2
        colnames(start.tab)[1:4] <- c("SampleID", "seqnames", "start", "end")
        start.tab.new <- start.tab
        if ( nrow(start.tab) != 0 ){
            for (i in 1:nrow(start.tab)){
                if ( start.tab$start[i] == 1 ){
                    start.tab.new <- start.tab.new[-i,]
                }
            }
        }
        s2.start <- start.tab.new
        
        end.tab <- segs2
        colnames(end.tab)[1:4] <- c("SampleID", "seqnames", "start", "end")
        end.tab.new <- end.tab
        if ( nrow(end.tab) != 0 ){
            for (i in 1:nrow(end.tab)){
                mx <- max(m.end[which(m.chr == end.tab$seqnames[i])]) 
                if ( end.tab$end[i] == mx ){
                    end.tab.new <- end.tab.new[-i,]
                }
            }
        }
        s2.end <- end.tab.new
        
        #find total number of breakpoints
        x$total_bp[j] <- as.numeric(nrow(s1.start) + nrow(s1.end) + nrow(s2.start) + nrow(s2.end))
        x$sample1_bp[j] <- as.numeric(nrow(s1.start) + nrow(s1.end) )
        x$sample2_bp[j] <- as.numeric( nrow(s2.start) + nrow(s2.end))
    }
    
    x$non_shared_bp <- x$total_bp - x$shared_bp
    x$sample1_bp <- x$sample1_bp - (x$shared_bp/2)
    x$sample2_bp <- x$sample2_bp - (x$shared_bp/2)
    
    #count to fraction 
    x$fraction_s1 <- x$sample1_bp/x$total_bp
    x$fraction_s2 <- x$sample2_bp/x$total_bp
    x$fraction_shared <- x$shared_bp/x$total_bp
    
    #sort samples by relatedness and shared fraction
    x$relatedness = factor(x$relatedness, levels = c("Related", "Ambiguous", "Unrelated"))
    x <- x[order(x$relatedness, x$fraction_shared),] 
    
    #build matrix to plot
    mat <- as.matrix(data.frame(s2 = x$fraction_s2, s1 = x$fraction_s1, shared = x$fraction_shared))
    row.names(mat) <- x$pat_id
    
    #plot
    require(ComplexHeatmap)
    ha_list <-  HeatmapAnnotation("#breaks" = anno_barplot(x$total_bp,
                                                           gp = gpar(fill = "grey50",
                                                                     col = "grey50"),
                                                           height = unit(1.7, "cm"),
                                                           border = FALSE), 
                                  annotation_name_rot = 90,
                                  annotation_name_side = "left",
                                  annotation_name_gp = gpar(fontsize = 8)
                                  ) %v% 
                HeatmapAnnotation(stacked = anno_barplot(mat[,c(2,1,3)],
                                                 gp = gpar(fill = c("#3987bb", "#aee7ea","#0c0d0c"),
                                                           col = c("#3987bb", "#aee7ea","#0c0d0c")),
                                                 height = unit(1.9, "cm"),
                                                 border = FALSE),
                                  show_annotation_name = FALSE
                                  ) %v%
                HeatmapAnnotation(" " = anno_barplot(x$pair_scores,
                                             gp = gpar(fill = "#b48c9c",
                                                       col = "#b48c9c", border = NA, lty = "blank"),
                                             height = unit(1.7, "cm"),
                                             border = FALSE),
                                  annotation_name_rot = 90,
                                  annotation_name_side = "left",
                                  annotation_name_gp = gpar(fontsize = 8)
                                  ) %v% 
                HeatmapAnnotation(relatedness = x$relatedness,
                                  recurrence = rep("Invasive", nrow(x)),
                                  col = list(relatedness = c("Related" = "#f5c61a", "Ambiguous" = "#fb4f14", "Unrelated" = "#660c21"),
                                             recurrence = c("DCIS" = "#e6cde3", "Invasive" = "#af67a7")),
                                  show_annotation_name = FALSE,
                                  border = TRUE,
                                  show_legend = FALSE,
                                  simple_anno_size = unit(0.35, "cm")
                                  ) %v%
                HeatmapAnnotation(id = anno_text(gt_render(rownames(mat),
                                                   gp = gpar (fontsize = 7)))
                                  )
    
    l1 <- Legend(title = "Breakpoint type", labels = c("All breakpoints", "Shared", "Primary private", "Recurrence private" ), legend_gp = gpar(fill = c("#6c6d69", "#0c0d0c", "#3987bb", "#aee7ea")),legend_height = unit(0.4, "cm") )
    l2 <- Legend(title = "", labels = "Breakclone score", legend_gp = gpar(fill = c("#b48c9c")),legend_height = unit(0.4, "cm"))
    l3 <- Legend(title = "Clonality", labels = c("Related", "Ambiguous", "Unrelated"), legend_gp = gpar(fill = c("#f5c61a", "#fb4f14", "#660c21")),legend_height = unit(0.4, "cm"))
    l4 <- Legend(title = "Recurrence Type", labels = c("DCIS", "Invasive"), legend_gp = gpar(fill = c("#e6cde3", "#af67a7")),legend_height = unit(0.4, "cm"))
    
    draw(ha_list, heatmap_legend_list = list(l1, l2, l3, l4))
}
