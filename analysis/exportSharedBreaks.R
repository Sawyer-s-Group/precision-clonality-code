#' @title exportSharedBreaks()
#' @description Export shared breakpoints between a pair of samples.
#' @param x A character vector with a the IDs of a pair of samples.
#' @param segmentTable A segment table generated by the breakclone::readAlleleSpecific or breakclone::readVCFCn functions.
#' @param outdir A character vector with a path to the output directory. If NULL, the result won't be exported.
#' @details This function contains code from breakclone package.
#' @examples 
#' exportSharedBreaks(copyNumberSegmented)
#' @examples2 Being pairs a table of paired samples from the dataset, the following code will export shared break points for all the pairs.
#' apply(pairs, 1, function(x){exportSharedBreaks(as.character(x), segmentTable = segmentTable, cnType = "VCF", outdir = ".")})
#' @export
exportSharedBreaks <- function(x, segmentTable, cnType, outdir = NULL){
    require(GenomicRanges)
    
    #handlePloidy function from breakclone package
    handlePloidy <- function(sample){
        sample$segLen <- sample$End - sample$Start
        sample_states <- aggregate(segLen ~ nTotal, sample, sum)
        sample_states$adjLen <- as.numeric(sample_states$nTotal) * sample_states$segLen
        sample_ploidy <- sum(sample_states$adjLen) / sum(sample$segLen)
        
        df <- as.data.frame(sample[-which(sample[,"Chr"]=="X"),])
        
        start <- as.numeric(df[which(df$nMinor == 0),"Start"])
        end <- as.numeric(df[which(df$nMinor == 0),"End"])
        length <- sum(end - start)
        length <- ifelse(is.na(length), 0, length)
        
        total.length <- sum(df[,"End"] - df[,"Start"])
        fgloh <- length/total.length
        cutoff <- 2.6-(4/3)*fgloh
        
        if(sample_ploidy > cutoff){
            warning("Sample ", sample$SampleID[1], " looks WGD, inferring ancestral Cn state")
            sample$nTotal <- ifelse(sample$nMinor == (sample$nTotal / 2), 2, sample$nTotal)
            sample$nTotal <- ifelse(sample$nMinor == 0, 1, sample$nTotal)
            sample$nTotal <- ifelse(sample$nTotal >= 3 & sample$nTotal <= 4 & sample$nMinor == 1, 2, sample$nTotal)
            sample$nTotal <- ifelse(sample$nTotal >= 5 & sample$nTotal <= 10, 3, sample$nTotal)
        }
        return(sample)
    }
    
    sample1 <- segmentTable[segmentTable$SampleID == x[1],]
    sample2 <- segmentTable[segmentTable$SampleID == x[2],]
    
    if(cnType == "alleleSpecific"){
        sample1$nTotal <- sample1$nMajor + sample1$nMinor
        sample2$nTotal <- sample2$nMajor + sample2$nMinor
        
        sample1 <- handlePloidy(sample1)
        sample2 <- handlePloidy(sample2)
        
        sample1$status <- ifelse(sample1$nTotal < 2, "loss", ifelse(sample1$nTotal == 2 & sample1$nMinor == 1, "norm", ifelse(sample1$nTotal == 2 & sample1$nMinor == 0, "cnloh", ifelse(sample1$nTotal > 4, "amp", "gain"))))
        sample2$status <- ifelse(sample2$nTotal < 2, "loss", ifelse(sample2$nTotal == 2 & sample2$nMinor == 1, "norm", ifelse(sample2$nTotal == 2 & sample2$nMinor == 0, "cnloh", ifelse(sample2$nTotal > 4, "amp", "gain"))))
        
        sample1 <- sample1[!"norm", on = "status"]
        sample2 <- sample2[!"norm", on = "status"]
        
        sample1_lists <- c(list(sample1["loss", on = "status"]), list(sample1["cnloh", on = "status"]), list(sample1["gain", on = "status"]), list(sample1["amp", on = "status"]))
        sample2_lists <- c(list(sample2["loss", on = "status"]), list(sample2["cnloh", on = "status"]), list(sample2["gain", on = "status"]), list(sample2["amp", on = "status"]))
        
    } else if(cnType == "VCF"){
        presentStates <- unique(c(sample1$SVType, sample2$SVType))
        
        sample1_lists <- sapply(presentStates, function(x){c(list(sample1[x, on = "SVType"]))})
        sample2_lists <- sapply(presentStates, function(x){c(list(sample2[x, on = "SVType"]))})
    }
    
    sample1_granges <- lapply(sample1_lists, function(x){tryCatch({makeGRangesFromDataFrame(x)}, error = function(e){GRanges()})})
    sample2_granges <- lapply(sample2_lists, function(x){tryCatch({makeGRangesFromDataFrame(x)}, error = function(e){GRanges()})})
    
    #calculateMaxGap function from breakclone package
    calculateMaxGap <- function(segmentTable, cnType){
        if(cnType == "alleleSpecific"){
            avgProbeDistance <- mean((segmentTable$End - segmentTable$Start) / segmentTable$nProbes)
            maxgap <- 5 * avgProbeDistance
        } else if(cnType == "VCF"){
            possBinSizes <- unique(segmentTable$Length / segmentTable$Bins)
            binSize <- possBinSizes[which.max(tabulate(match(segmentTable$Length / segmentTable$Bins, possBinSizes)))]
            maxgap <- 5 * binSize
        }
        return(maxgap)
    }
    
    maxgap <- calculateMaxGap(segmentTable, cnType)
    
    hits_start <- mapply(function(x,y){x[queryHits(suppressWarnings(findOverlaps(x,y, type = "start", maxgap = maxgap)))]}, sample1_granges, sample2_granges)
    hits_end <- mapply(function(x,y){x[queryHits(suppressWarnings(GenomicRanges::findOverlaps(x,y, type = "end", maxgap = maxgap)))]}, sample1_granges, sample2_granges)
    
    if(cnType == "alleleSpecific"){
        start <- rbind(as.data.frame(hits_start[[1]]), as.data.frame(hits_start[[2]]), as.data.frame(hits_start[[3]]), as.data.frame(hits_start[[4]]))[,-5]
        start$seqnames <- as.character(start$seqnames)
        end <- rbind(as.data.frame(hits_end[[1]]), as.data.frame(hits_end[[2]]), as.data.frame(hits_end[[3]]), as.data.frame(hits_end[[4]]))[,-5]
        end$seqnames <- as.character(end$seqnames)
    
    } else if(cnType == "VCF"){
        presentStates <- unique(c(sample1$SVType, sample2$SVType))
        
        sample1_lists <- sapply(presentStates, function(x){c(list(sample1[x, on = "SVType"]))})
        sample2_lists <- sapply(presentStates, function(x){c(list(sample2[x, on = "SVType"]))})
    }
    res <- rbind(start,colnames(start),end)
    
    if (!is.null(outdir)){
        write.table(res, paste0(outdir, "/", x[1],"-",x[2], ".tsv"), sep = "\t", row.names = FALSE, quote = FALSE)
        print(paste0("Shared Breakpoints ", x[1], "-", x[2],  " saved in ", outdir))
    }
    
    return(res)
}